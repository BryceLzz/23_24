import threading
import gi
import requests
import gettext
import locale

# Configurar el directorio de traducciones
locale_dir = 'locales'
gettext.bindtextdomain('CocktailApp', locale_dir)
gettext.textdomain('CocktailApp')
lang = locale.getdefaultlocale()[0]
lang = 'es' if lang.startswith('es') else 'en'
_ = gettext.gettext

gi.require_version('Gtk', '4.0')
from gi.repository import Gtk, GLib
from controller import CocktailController

class ResultWindow(Gtk.ApplicationWindow):
    def __init__(self, application, search_term, search_type):
        super().__init__(application=application)
        self.set_title(_("Resultados de la búsqueda"))
        
        # Create a Label to display the search results
        result_label = Gtk.Label(label=_(
            f"Resultados para '{search_term}' (Búsqueda por {search_type}):"))
        
        # Create a ScrolledWindow to hold the results
        scrolled_window = Gtk.ScrolledWindow()
        result_grid = Gtk.Grid()

        # Creamos un hilo para ejecutar la búsqueda en segundo plano
        search_thread = threading.Thread(target=self.perform_search, args=(search_term, search_type, result_grid))
        search_thread.start()

        scrolled_window.set_child(result_grid)
        # Create a Button to close the result window
        close_button = Gtk.Button(label=_("Cerrar"))
        close_button.connect("clicked", self.on_close_button_clicked)
        
        # Create a Box to organize the elements
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        box.append(result_label)
        box.append(scrolled_window)
        box.append(close_button)
        
        self.set_child(box)

    def perform_search(self, search_term, search_type, result_grid):
        search_results = CocktailController.perform_search(search_term, search_type)

        if search_results is None:
            # Si hay un error de conexión, muestra la ventana de error
            error_message = _("Error de conexión: No se pudo realizar la búsqueda.")
            GLib.idle_add(self.show_error_window, error_message)
        elif not search_results:
            # Si no hay resultados válidos, muestra un mensaje
            no_results_label = Gtk.Label(label=_("No se encontraron resultados"))
            GLib.idle_add(self.add_to_grid, result_grid, no_results_label, 0, 0, 1, 1)
        else:
            row, col = 0, 0
            for result in search_results:
                result_button = Gtk.Button(label=result["strDrink"] if search_type == "Cóctel" else result["strIngredient"])
                result_button.connect("clicked", self.on_result_button_clicked, result)
                GLib.idle_add(self.add_to_grid, result_grid, result_button, col, row, 1, 1)
                col += 1
                if col >= 5:
                    col = 0
                    row += 1

    def add_to_grid(self, result_grid, widget, col, row, col_span, row_span):
        result_grid.attach(widget, col, row, col_span, row_span)

    def on_result_button_clicked(self, button, result):
        if "strDrink" in result:  # Comprobar si es un cóctel
            thread = threading.Thread(target=self.fetch_cocktail_details, args=(result,))
            thread.start()
        else:  # De lo contrario, es un ingrediente
            ingredient_name = result["strIngredient"]
            thread = threading.Thread(target=self.fetch_cocktails_by_ingredient, args=(ingredient_name,))
            thread.start()

    def fetch_cocktail_details(self, cocktail):
        ingredients = CocktailController.fetch_cocktail_details(cocktail)

        if ingredients is None:
            # Si hay un error de conexión, muestra la ventana de error
            error_message = _("Error de conexión: No se pudieron obtener los ingredientes.")
            GLib.idle_add(self.show_error_window, error_message)
        else:
            cocktail_name = cocktail["strDrink"]
            ingredients_text = "\n".join(ingredients)
            GLib.idle_add(self.show_ingredients_window, cocktail_name, ingredients_text)

    def fetch_cocktails_by_ingredient(self, ingredient_name):
        cocktails = CocktailController.fetch_cocktails_by_ingredient(ingredient_name)

        if cocktails is None:
            # Si hay un error de conexión, muestra la ventana de error
            error_message = _("Error de conexión: No se pudieron obtener los cócteles con el ingrediente.")
            GLib.idle_add(self.show_error_window, error_message)
        else:
            cocktails_text = "\n".join([cocktail["strDrink"] for cocktail in cocktails])
            GLib.idle_add(self.show_cocktails_window, ingredient_name, cocktails_text)
    
    def show_cocktails_window(self, ingredient_name, cocktails_text):
        cocktails_window = CocktailsWindow(application=self.get_application(), ingredient_name=ingredient_name, cocktails=cocktails_text)
        cocktails_window.present()

    def show_ingredients_window(self, cocktail_name, ingredients_text):
        ingredients_window = IngredientsWindow(application=self.get_application(), cocktail_name=cocktail_name, ingredients=ingredients_text)
        ingredients_window.present()

    def show_error_window(self, error_message):
        error_window = ErrorOccurredWindow(application=self.get_application(), error_message=error_message)
        error_window.present()


    def on_close_button_clicked(self, button):
        self.destroy()

# Resto del código...

class IngredientsWindow(Gtk.ApplicationWindow):
    def __init__(self, application, cocktail_name, ingredients):
        super().__init
